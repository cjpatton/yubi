\label{sec:otp}
%
This section specifies the Yubico OTP protocol in the manner in which it is
generally deployed.\footnote{See
\url{https://developers.yubico.com/OTP/Specifications}.}
%
In order to simplify the exposition, we will not assume the use of a YubiHSM;
note, however, that the HSM could be used to keep all sensitive values hidden from
the authority, effectively reducing trust in the authority to trusting that the
HSM has been properly configured.
%
We begin with a bit of notation.

\heading{Notation.}
If~$n$ is a positive integer, let $[1..n]$ denote the set of integers from~$1$ to~$n$.
%
Variables are strings unless noted otherwise.
%
Strings are finite sequences of bytes, i.e., elements of $(\bits^8)^*$, unless
noted otherwise. Let~$\emptystr$ denote the empty string.
%
Let~$X$ and~$Y$ be strings and let $X \cat Y$ denote their concatenation.
%
String indexing has the same semantics as the Python programming language: let
$0 \leq i \leq j \leq |X|-1$. Then $X[i]$ denotes $(i+1)$-th byte of~$X$ and
$\substr(X,i,j)$ denotes the sub string $X[i] \cat \cdots \cat X[j-1]$ of $X$.
Let $\substr(X,i,) = \substr(X,i,|X|-1)$ and $\substr(X,,j) = \substr(X,0,j)$.
%
If $i \geq j$, then $\substr(X,i,j) = \emptystr$ by convention.
%
Let $\str(X)$ denote the modhex encoding of~$X$.\footnote{OTPs
use the alphabet \texttt{cbdefghijklnrtuv} instead of the usual
\texttt{0123456789abcdef} for encoding nibbles.}
%
Let $\byte(i) \in \bits^8$ denote the byte encoding of integer $i\in[0..255]$.

\heading{The data frame.}
The \key stores a 16-byte key~$K$. When activated, it emits a 44-byte string,
called a \emph{one-time password}.
%
An OTP is a modhex string $\str(I \cat Y)$, where $|I|=6$ and $|Y|=16$.
%
String $I$ is the \emph{public identifier} of \key and $Y=E_K(X)$, where~$E$ denotes the
AES-128 block cipher and $X$ is a 16-byte string called the \emph{data frame}.
The data frame encodes the following quantities:
\begin{itemize}
  \item string $m$ ($\substr(X,,6)$) --- the payload.
  \item integer $\sctr$ ($\substr(X,6,8)$) --- the session counter.
    Changes each time $\tctr$ rolls over.
  \item integer $\tlow$ ($\substr(X,8,10)$) --- the low-order time stamp
    bits. Changes quickly.
  \item integer $\thigh$ ($X[10]$) --- the high-order time stamp
    bits. Changes slowly.
  \item integer $\tctr$ ($X[11]$) --- the token counter. Changes each
    time \key is invoked.
  \item string $r$ ($\substr(X,12,14)$) --- a pseudorandom value generated by
    \key. \cpnote{How is this seeded? Can this be reseeded?}
  \item integer $\crc$ ($\substr(X,14,)$) --- a checksum of
    $\substr(X,,14)$, denoted $\checksum(\substr(X,,14))$.\footnote{Computed as \texttt{0xffff} minus the output of
    \url{https://github.com/Yubico/yubico-c/blob/master/ykcrc.c}.}
\end{itemize}
The payload is the \emph{private identifier} of \key in the Yubico OTP protocol.
%
An OTP is deemed \emph{authentic} if the payload of the decrypted frame matches
the private ID the authority has on record \emph{and} the checksum is correct.
An OTP is \emph{fresh} if the counter is larger than the previous frame. To
enable this functionality, it suffices to have the authority store the frame of
the last authentic and fresh OTP it received. The \emph{initial frame} is
defined by setting the payload to the private ID, setting the counters, time
stamp, and pseudorandom bytes all to zero, and computing the checksum of the
frame.
%
Define $X.\ct$ as $X.\tctr + (X.\sctr \ll 8)$, where the $\ll$ dentos the bit
shift operator.

\heading{The protocol.}
Let $\client$ denote the client in possession of \key, $\server$ denote the
server, and~$\auth$ denote the authority.
%
The server and authority share a key~$K'$ for HMAC-SHA1, denoted $\mac$. The
protocol works as follows:
%
\begin{enumerate}
  \item $\client$ executes $(\otp, \sigma') \gets \key(\stringer{otp}, \sigma)$
    and transmits $\otp$ to $\server$.

  \item $\server$ computes $H = \mac_{K'}(J \cat N \cat \otp)$ and sends $(H, J,
    N, \otp)$ to $\auth$, where~$N$ is a nonce and~$J$ is $\server$'s identity.

  \item $\auth$ looks up the key $K'$ associated with~$J$ and checks that $H =
    \mac_{K'}(J \cat N \cat \otp)$. If so, it proceeds to step~4; otherwise it
    halts.

  \item $\auth$ decodes $\str(I\cat Y) \gets \otp$ and looks up the key~$K$ and
    data frame~$T$ associated with~$I$.
    %
    It computes $X \gets E_K^{-1}(Y)$, checks that $\otp$ is authentic (that $X.m =
    T.m$ and $\checksum(\substr(X,,14))=X.\crc$) and fresh (that $X.\ct > T.\ct$).
    %
    If both conditions hold, it lets $T \gets X$.  It lets~$R$ denote the result
    of check. Finally, it computes $H' = \mac_{K'}(N \cat R \cat \otp)$, and sends $(H',
    N, R, \otp)$ to $\server$.

  \item $\server$ checks that $H' = \mac_{K'}(N \cat R \cat \otp)$ and that the
    response~$R$ says that $\otp$ is authentic and fresh. If so, it accepts;
    otherwise it rejects.
\end{enumerate}

\textit{Initialization.}
The key~$K$ and initial frame~$T$ are generated and used to compute the $\key$'s
initial state~$\sigma$, and~$K$ and~$T$ are given to~$\auth$.
%
Next, key~$K'$ is generated and given to $\auth$ and $\server$.
%
The public identity~$I$ of $\key$ is given to~$\server$, and the identity~$J$ of
$\server$ is given to~$\auth$.

\textit{Verification of~$H$ is optional.}
%
Computing the MAC of the server request in step 2 and verification of MAC in
step 3 is an optional feature of the protocol. This step is not essential for
authenticating the client, but may be useful for other purposes.

\textit{Interpreting the result $R$.}
%
The contents of~$R$ are specified by the protocol.\footnote{See
\url{https://developers.yubico.com/OTP/Specifications/OTP_decryption_protocol.html}.}
If the $\otp$ is valid, then it includes the counter and the time stamp.
Otherwise it indicates what went wrong; for example, the $\otp$ was mal-formed,
inauthentic, or not fresh.

\subsection{Security}
We describe, informally, the goal of the Yubico OTP protocol.
%
Fix $c,s,t\in\N$.  The players are the set of clients $\{\client_i\}_{i\in[c]}$,
the set of servers $\{\server_j\}_{j\in[s]}$, the set of
tokens~$\{\key_k\}_{k\in[t]}$, and the authority~$\auth$.
%
A client may be in possession of any number of tokens, but no token is possessed by
more than one client.
%
Clients ``register'' at most one token with each server, meaning the server is
given the public identity of the token.
%
A client may register any token with any server, and a single token may be used for
any number of servers.

\heading{Threat model.}
We adopt the threat model of~\cite{bellare1993entity}. The adversary is
active and controls all flows between players. We assume that the players are
initialized (as described above) before the attack begins.
%
Instances of the protocol, called \emph{sessions}, may be carried out
simultaneously.
%
Each session is initialized by the adversary and is defined by a triple
of positive integers $(i, j, k)$.
%
A \emph{valid session} is one in which the Yubico OTP protocol involving
$\client_i$, $\server_j$, $\key_k$, and $\auth$ is carried out faithfully, and
where $\client_i$  is ``in possession of'' $\key_k$.
%
A session is not valid unless it completes.
%
A session is called \emph{accepting} if $\server_j$ accepts in that session.
%
The goal of the adversary is to get \emph{any} server to accept in an
\emph{invalid} session. We say the protocol is secure if the probability that
any ``reasonable'' adversary can do so is negligible.

\textit{Physical assumptions.}
In our adversarial model, we assume that the tokens expose the interface
described in Section~\ref{sec:tokens}, and otherwise offer no attack surface.
%
Of course, this is a strong assumption that does not stand up to scrutiny. For
example, prior work has shown YubiKeys to be susceptible to side-channel
attacks~\cite{oswald2013side-channel}. Thus, an adversary in control of a
client's system, or in physical proximity of the token, may have access to
additional information not captured in the model.
%
\cpnote{This might make an interesting attack surface, but I'll ignore it for
the time being.}

In the following, we consider the various avenues of attack available to our
adversary.

\heading{Forging the authority response.}
The use of HMAC-SHA1 and the nonce~$N$ in the server response ensure that the
response is authentic and cannot be replayed. (Each server must take
care to make sure that it never repeats a nonce.) The MAC also binds the response
to the OTP, ensuring that if the OTP is valid, then the response is valid. In
the remainder, we focus on the validity of the OTP.

\newcommand{\forge}{\notionfont{FORGE}}
\newcommand{\sprp}{\notionfont{SPRP}}
\newcommand{\advF}{\algorithmfont{F}}
\newcommand{\advD}{\algorithmfont{D}}
\newcommand{\calK}{\mathcal{K}}
\newcommand{\calE}{\mathcal{E}}
\newcommand{\win}{\varfont{win}}
\newcommand{\KEYO}{\oraclefont{Key}}
\newcommand{\AUTHO}{\oraclefont{Auth}}
\newcommand{\Perm}{\mathrm{Perm}}
\newcommand{\Dom}{\mathrm{Dom}\,}
\newcommand{\Rng}{\mathrm{Rng}\,}
\begin{figure}[t]
  \newcommand{\isvalid}{\schemefont{isvalid}}
  \twoCols{0.48}
  {
    \underline{$\Exp{\forge}_{E,S}(\advF)$}\\[2pt]
      $\calE \gets \emptyset$;
      $K \getsr \calK$;
      $T \gets S$;
      $\win \gets \false$;
      $\advF^{\,\KEYO,\AUTHO}(S)$\\
      return $\win$
    \\[6pt]
    \underline{$\KEYO(\,)$}\\[2pt]
      $S.\ct \gets S.\ct + 1$;
      $Y \gets E_K(S)$;
      $\calE \gets \calE \union \{Y\}$;
      return $Y$
    \\[6pt]
    \underline{$\AUTHO(Y)$}\\[2pt]
      $X \gets E_K^{-1}(Y)$\\
      if $\isvalid(X,T)$ then\\
      \tab if $Y \not\in \calE$ then $\win \gets \true$\\
      \tab $T \gets X$\\
      return $X$\\[2pt]
    \hrule
    \vspace{5pt}
    \underline{$\Exp{\sprp}_{E,b}(\advD)$}\\[2pt]
      $K \getsr \calK$; $\pi \getsr \Perm(n)$\\
      if $b=1$ then $b' \getsr \advD^{E_K(\cdot),E_K^{-1}(\cdot)}$\\
      else $b' \getsr \advD^{\pi(\cdot),\pi^{-1}(\cdot)}$\\
      return $b'$
  }
  {
    \underline{$\G^c_S(\advF)$}\\[2pt]
      $\calE \gets \emptyset$;
      $T \gets S$;
      $\win \gets \false$;
      $\advF^{\,\KEYO,\AUTHO}(S)$\\
      return $\win$
    \\[6pt]
    \underline{$\KEYO(\,)$}\\[2pt]
      $S.\ct \gets S.\ct + 1$\\
      if $S \not\in \Dom \pi$ then $\pi(S) \getsr \bits^n \setminus \Rng \pi$\\
      $\calE \gets \calE \union \{\pi(S)\}$;
      return $\pi(S)$
    \\[6pt]
    \underline{$\AUTHO(Y)$}\\[2pt]
      if $Y \in \calE$ then $X \gets \pi^{-1}(Y)$\\
      \tab if $\isvalid(X,T)$ then $T \gets X$\\
      \tab return $X$\\
      $X \getsr \bits^n$\\
      if $X \in \Dom \pi$ then\\
      \tab $\bad \gets \true$; if $c=1$ then $X \getsr \bits^n \setminus \Dom \pi$\\
      $\pi^{-1}(Y) \gets X$\\
      if $\isvalid(X,T)$ then\\
      \tab $\win \gets \true$; $T \gets X$\\
      return $X$
  }
  \caption{Let $E:\calK\cross\bits^n\to\bits^n$ be a blockcipher, $\calK$ be a
    finite set, and $n\in\N$. Let $\Perm(n)$ denote the set of all permutations
    over $\bits^n$. Let $\isvalid(X,T)$ denote the predicate $(X.m = T.m) \AND (X.\crc =
    \checksum(\substr(X,,14))) \AND (X.\ct > T.\ct)$.
  \textbf{Top-left:} the \forge game for~$E$;
  \textbf{Bottom-left:} the \sprp game for~$E$; and
  \textbf{Right:} a game used to fix Lemma 1.}
  \label{fig1}
  \vspace{6pt}
  \hrule
\end{figure}
\heading{Forging an OTP.}
A successful forgery is an attack whereby the adversary transmits an OTP to a
server that the authority deems authentic and fresh, but was not output by the
token.
%
An OTP is merely the AES encryption of some ``stuff'' using a key shared between
each $\key_k$ and $\auth$, and so it is natural to reduce an adversary's ability
to forge to the security of AES.
%
Typically we would assume that AES is a good \emph{pseudorandom permutation},
meaning that no ``reasonable'' adversary can distinguish the output of the
blockcipher from a true random permutation, even if the adversary chooses the
inputs.
%
However, this does not suffice for our setting, since the forgery adversary has,
in effect, an oracle for the permutation \emph{and} its inverse. A more
appropriate assumption is that AES a is a \emph{strong pseudorandom
permutation}.

Let $n\in\N$, $\calK$ be a finite set, and let $E:\calK\cross\bits^n\to\bits^n$
be a blockcipher. We associated to $E$, an adversary~$\advD$, and bit~$b$ a
game, \sprp, defined in Figure~\ref{fig1}.
%
If $b=1$, then a key~$K$ is chosen uniformly from the set~$\calK$ and~$\advD$ is
given access to oracles~$E_K(\cdot)$ and $E_K^{-1}(\cdot)$.
%
Otherwise, a permutation $\pi$ is chosen uniformly from the set of all
permutations over~$\bits^n$ and the adversary is given oracles for~$\pi$ and its
inverse.
%
Eventually it outputs a bit~$b'$, which is returned by the game. We define the
advantage of~$\advD$ in attacking~$E$ as
\[
  \Adv{\sprp}_E(\advD) = \left| \Prob{\Exp{\sprp}_{E,1}(\advD)\outputs\true} -
                                \Prob{\Exp{\sprp}_{E,0}(\advD)\outputs\true}
                              \right|\,.
\]
Informally, we call~$E$ a strong pseudorandom permutation if
$\Adv{\sprp}_E(\advD)$ is ``small'' for all ``reasonable''~$\advD$.

We note that there is a significant gap between PRP and \sprp security. On the
theoretical side, there are constructions of blockciphers that are provably
secure as PRPs, but are \emph{not} SPRPs, e.g. the Feistel constructions
of~\cite{luby1988how}.
%
On the other hand, the \sprp security of AES has undergone significant
cryptanalysis, e.g. using the boomerang attack of
Wanger~\cite{wagner1999boomerang}. It is generally believed (and often assumed)
that AES-128 is a secure \sprp.

\textit{One client, one token, and one server.}
Under the \sprp assumption, we can prove a useful lemma that helps us quantify the
adversary's ability to forge an OTP. Suppose for the moment that there is just
one client with a single token registered with one server.
%
We may formalize the forgery attack as the game \forge defined in
Figure~\ref{fig1}. The game is parameterized by an \emph{initial data
frame}~$S$, which specifies the shared state between the token and authority
before the attack begins.
The adversary~$\advF$ is given an oracle~$\KEYO$ for the
token and an oracle~$\AUTHO$ for authenticating OTPs.
%
The game sets a flag~$\win$ if the
adversary makes an $\AUTHO$-query that is fresh and authentic, but was never
output by~$\KEYO$. The outcome of the game is the value of~$\win$ when~$\advF$
halts. We define the advantage of~$\advF$ in forging against~$E$ (beginning at
state~$S$) as
\[
  \Adv{\forge}_{E,S}(\advF) = \Prob{\Exp{\forge}_{E,S}(\advF)\outputs\true} \,.
\]

\heading{Lemma 1. }\emph{Let $n=128$, $\calK$ be a finite set, and
  $E:\calK\cross\bits^n\to\bits^n$ be a blockcipher.
  Let $S \in \bits^n$ be a data frame and let $\tau = S.\ct < 2^{24}$.
  Let $\advF$ be a \forge adversary making~$\kappa<2^{24}$ queries to~$\KEYO$
  and~$\alpha$
  queries to~$\AUTHO$.
  There exists an \sprp adversary~$\advD$ such that
  \[
    \Adv{\forge}_{E,S}(\advF) \leq
      \Adv{\sprp}_E(\advD)
      + \frac{\alpha^2+2\kappa\alpha}{2^{129}}
      + \frac{\alpha(2^{24}-\tau)}{2^{88}}
  \]
  where~$\advD$ has the same runtime as~$\advF$.
}\\[2pt]
\textit{Proof.}
%
Adversary~$\advD$ is constructed by simulating~$\advF$ in its game in the
natural way. In particular, calls to the blockcipher (i.e. the call to~$E$
in~$\KEYO$) are forwarded to~$\advD$'s first oracle, and calls to the inverse of
the blockcipher (i.e. the call to~$E^{-1}$ in~$\AUTHO$) are forwarded
to~$\advD$'s second oracle. Once~$\advF$ halts, adversary~$\advD$ halts and
outputs~$\true$ if $(\win=\true)$ and~$\false$ otherwise.

Let~$b$ denote the challenge bit in~$\advD$'s game. If $b=1$, then the
simulation is perfect; otherwise ~$\advD$'s output is identically distributed
to the output of $\G^1_S(\advF)$, where game~$\G^1$ is as defined in
Figure~\ref{fig1}. (This game is the same as the \forge game instantiated with a random
permutation rather than a blockcipher. The permutation is simulated via lazy
evaluation.) It follows that
\begin{eqnarray*}
  \Adv{\sprp}_E(\advD) &=& \Prob{\Exp{\sprp}_{E,1}(\advD)\outputs\true} -
                           \Prob{\Exp{\sprp}_{E,0}(\advD)\outputs\true}\\
                       &=& \Prob{\Exp{\forge}_{E,S}(\advF)\outputs\true} -
                           \Prob{\G^1_S(\advF)\outputs\true}\,.
\end{eqnarray*}

We next note the random variables $\G^1_S(\advF)$ and $\G^0_S(\advF)$ are
identically distributed until either game sets the flag~$\bad\gets\true$.
This occurs if~$\advF$ asks $\AUTHO(Y)$, where~$Y$ was never output by~$\KEYO$,
and~$X$ chosen uniformly from~$\bits^n$ is in the domain of~$\pi$. On the $i$-th
query to $\AUTHO$ This occurs with probability at most $(\kappa + i - 1)/2^n$.
Summing over all~$\alpha$ queries yields
\[
  \left| \Prob{\G^1_S(\advF)\outputs\true} - \Prob{\G^0_S(\advF)\outputs\true}
  \right| \leq \frac{2\kappa\alpha + \alpha^2}{2^{n+1}}\,.
\]

We need only bound $\Prob{\G^0_S(\advF)\outputs\true}$. In this game, each query
to~$\AUTHO(Y)$ such that $Y$ was never output by~$\KEYO$ samples an~$X$ from
$\bits^n$ independently of all previous queries. Hence, the probability that
that $\win$ gets set, i.e. $X.m = T.m$, $X.\crc=\checksum(\substr(X,,14))$, and
$X.\ct > T.\ct$, is independent for each query.
%
The payload ($X.m$) is the first 48 bits (6 bytes), the checksum $(X.\crc)$ is
the last 16 bits (2 bytes), and the counter $(X.\ct)$ is comprised of 24  bits
(3 bytes). Since these values are non-overlapping, there are at most
$2^{n-88}(2^{24}-\tau)$ values for~$X$ that would set~$\win$. (The precise
number depends on the number of OTPs ``delivered'' by the adversary, i.e. the
number of queries $\AUTHO(Y)$ such that~$Y$ was output by $\KEYO$.) Since~$X$ is
a uniform random string, it follows
that
\[
  \Prob{\G^0_S(\advF)\outputs\true} \leq \frac{\alpha(2^{24}-\tau)}{2^{88}}\,.
\]
This yields the final bound.
%
\qed

\textit{Interpreting the bound.}
%
The Yubico OTP protocol achieves roughly birthday-bound (i.e., 64-bit, half
the block length) security in the \forge game, meaning the bound becomes vacuous
after the adversary makes about $\alpha=2^{64}$ forgery attempts. (Or somewhat
less, depending on the value of ~$\kappa$, which is the number of OTPs the
adversary gets to see.)
%
The last term in the bound gets smaller as the initial counter value
increases, but is at most~$\alpha/2^{64}$ (i.e., when $\tau=0$).
%
Of course, this bound should not be interpreted as the concrete security for the
overall protocol; it only captures one attack vector. However, we can conclude
that the concrete security of the overall protocol is no better than this.

\heading{Rerouting an OTP.}
Lemma 1 captures an adversary's ability to forge an OTP when there is just one
client, one token, and one server. More generally, suppose there are any number
of clients, tokens, and servers, but each token is used to authenticate the
client to at most one server. It's not difficult to see that security in this
more general setting reduces to \forge security. (Perhaps with a small cost in
concrete security.)
%
However, if we allow a client to register a single token with more than
one server, then there is a trivial attack whereby the adversary simply
\emph{reroutes} an OTP meant for one server to another.
%
Suppose that $\client_i$ has registered $\key_k$ with servers $\server_j$ and
$\server_{j^*}$.
%
The adversary initiates a session $(i,j,k)$ and runs it until $\key_k$ outputs
$\otp$ to $\client_i$.
%
It then initiates a new session $(i,j^*,k)$, but instead of faithfully running
the protocol, it sends $\otp$ to $\server_{j^*}$, then runs the protocol from that
point forward. In the end, $\server_{j^*}$ will accept, although the session is
invalid.

\heading{Conclusion.}
%
The Yubico OTP protocol appears to provide strong (at least birthday-bound)
security as long as a client never uses the same token for more than one
service, since an adversary that can intercept an OTP can easily use it to
authenticate to another service.
%
A na\"ive solution would be to require the client and server to use TLS so that
the OTP is not sent in the clear. But unless the client and server are mutually
authenticated during the handshake, the channel is vulnerable to a
man-in-the-middle attack. Since the OTP is itself a means of authentication,
this is not a viable solution.

\textit{The private identifier is useless.}
The \forge game is parameterized by the initial data frame, which models the
shared state between the token and authority in the protocol.  The data frame is
given to the adversary in the game, Hence, the private identifier being secret
is not essential for security. It suffices to have a public identifier and a
secret key associated with it. As Lemma~1 indicates, the payload can be
anything, for example, the all zero string. Indeed, many of the components of
the data frame can be removed without compromising security: in particular, the
checksum, the pseudorandom value, and time stamp. We only need the payload (some
publicly-known value) and the counter.
